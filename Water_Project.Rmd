---
title: "Water_Project"
author: "Justin Howard"
date: "June 6, 2019"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=F}
library(tidyverse)
library(stringr)
library(dplyr)
library(lubridate)
setwd('C:/Users/howar/Documents/r__working_directory/Water_Project')
```

```{r well descriptions, inlcude=F}
wellmain<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WellMain.txt", sep="|", header=T,
                      stringsAsFactors = T, strip.white = T, quote="", comment.char = "", fill = T)
```
```{r loading water quality data, include=F}
qualitymajor<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WaterQualityMajor.txt", sep="|",
                          header=T,stringsAsFactors = T, strip.white = T, quote="", comment.char = "", 
                          fill = T)

qualitycombination<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WaterQualityCombination.txt",
                                sep="|", header=T, stringsAsFactors = T, strip.white = T, quote="",
                                comment.char = "", fill = T)

#loading levels data
levelsmajor<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WaterLevelsMajor.txt", sep="|",
                          header=T,stringsAsFactors = T, strip.white = T, quote="", comment.char = "", 
                          fill = T)
levelscombo<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WaterLevelsCombination.txt", sep="|",
                          header=T, stringsAsFactors = T, strip.white = T, quote="", comment.char = "", 
                          fill = T)
```

#### We are choosing to limit the scope of this analysis to the Ogallala Aquifer, on wells located in Lubbock County, located in the Panhandle region of Texas. This aquifer was picked because its level of recharge is very slow, limiting the effect of rainfall on the analysis. Our data comes from the Texas Groundwater Conservation Board.
```{r isolating data on the Ogallala Aquifer on wells in Lubbock County}
# water quality -- the qualityminor and qualityother tables had no ogallala
ogaqualitymajor<- qualitymajor %>%
  filter(str_detect(Aquifer, "Ogallala")) %>%
  filter(str_detect(County, "Lubbock"))
ogaqualitycombo<- qualitycombination %>%
  filter(str_detect(Aquifer, "Ogallala")) %>%
  filter(str_detect(County, "Lubbock"))
ogaqualityAll<- list(ogaqualitycombo, ogaqualitymajor)
ogaqualityAll<- do.call("rbind", ogaqualityAll)

# water levels
ogalevelsmajor<- levelsmajor %>%
  filter(str_detect(Aquifer, "Ogallala")) %>%
  filter(str_detect(County, "Lubbock"))
ogalevelscombo<- levelscombination %>%
  filter(str_detect(Aquifer, "Ogallala")) %>%
  filter(str_detect(County, "Lubbock"))
ogalevelsAll<- list(ogalevelscombo, ogalevelsmajor)
ogalevelsAll<- do.call("rbind", ogalevelsAll)

# getting aggregate values of water elevation by year
levelsbyyear<- aggregate(WaterElevation ~ MeasurementYear, ogalevelsAll, mean)
names(levelsbyyear)<- c("SampleYear", "MeanWaterLvl")

# combining tables to get more variables to select from
final<- merge(ogaqualityAll, wellmain, by = "StateWellNumber")
# filtering based on the response variable
finalTDS<- final %>%
  filter(str_detect(ParameterDescription, "TOTAL DISSOLVED SOLIDS"))
# filtering out wells without welldepth values
TDSDepth<- finalTDS %>%
  drop_na(WellDepth)
```

```{r plotting the response, include=F}

panel.cor <- function(x, y){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- round(cor(x, y), digits=2)
    txt <- paste0("R = ", r)
    text(0.5, 0.5, txt)
}

pairs(~ParameterValue + SampleYear + LandSurfaceElevation + LatitudeDD + LongitudeDD + WellDepth
      + MeanWaterLvl, 
      lower.panel = panel.cor,
      data = TDS_Waterlvl)
```

#### The correlations beween GPS coordinates and land elevation are high. A previous study of water quality found signficant evidence that that wells in the northern portion of the Ogallala Aquifer had overall lower TDS levels than those in the southern portion. To see if this holds true for Lubbock County as well, we will keep latitude and longitude coordinates over land elevation. LandSurfaceElevation may need to be removed from the model. 
MeanWaterlvl is highly corrleated with Year, so Year will be removed from the model, but investigated for trends over time.
Also of note: A signficant outlier appears to to be in a sample taken in year 1980.
```{r boxplot ParameterValue}
library(car)
  Boxplot(TDS_Waterlvl$ParameterValue, 
          main="Boxplot of ParameterValue",
          ylab = "Total Dissolved Solids (mg/L)",
          id.method = 'y')
## performing log transformation on response
    Boxplot(log(TDS_Waterlvl$ParameterValue), 
          main="Boxplot of log(ParameterValue)",
          ylab = "Total Dissolved Solids",
          id.method = 'y')
```
#### The tranformation has improved the distance between the outliers and the mean value. These observations will be removed to judge their effect on the model.

```{r removing outliers}
outliers<- c(215, 238, 202, 190, 189, 212, 180, 193, 204, 207)
noOutliers<- TDS_Waterlvl[-outliers,]
    Boxplot(log(noOutliers$ParameterValue), 
          main="Boxplot of log(ParameterValue)",
          ylab = "Total Dissolved Solids",
          id.method = 'y')
```

```{r scatterplots for categoricals}

pairs(~ParameterValue + ReportingAgency + Owner + Pump + PowerType + WellUse + WellType + AnalyzedLab,
      lower.panel = panel.cor,
      data = TDS_Waterlvl)
```
#### Aquifer and Classification appear to be strongly correlated, as do SampledAquifer and Classification. WellUse will stay in the model to control for the type of well being sampled from, but Pump and PowerType will be removed due to strong corrleations with WellType and WellUse. ReportingAgency, AnalyzedLab and Owner will also stay in the model to account for agency and owner habits.
WellType will be removed as there only appears to be one type of well in the data.

Before we proceed, we will look at scatterplots of a log transformed repsonse to see if outliers are dealt with.
```{r plots of log transformed ParameterValue}
pairs(~log(ParameterValue) + LatitudeDD + LongitudeDD + WellDepth + MeanWaterLvl, 
      lower.panel = panel.cor,
      main = "Log Transformed Response v. Continuous Variables",
      data = TDS_Waterlvl)
pairs(~log(ParameterValue) + ReportingAgency + Owner + WellUse + AnalyzedLab + SampleYear 
      + LatitudeDD + LongitudeDD,
      lower.panel = panel.cor,
      main = "Log Tranformed Response v. Variables to Account For",
      data = TDS_Waterlvl)
```
#### The outlier still appears relevant after the log transformation, confirming the need to compare models with and without the original outliers. A small correlation exists between Owner and WellUse, but this may be insignificant. Models with and without Owner will be compared.
Strong correlations exist between SampleYear, AnalyzedLab and ReportingAgency. AnalyzedLab and ReportingAgency will be removed.

```{r linear model with outliers}
#model with outliers
model1<- lm(log(ParameterValue)~ + LatitudeDD + LongitudeDD + Owner + WellUse + WellDepth
            + MeanWaterLvl, data = TDS_Waterlvl)
plot(model1$fitted.values, model1$residuals, main = "Model1, Outliers Included", xlab="Fitted Values", ylab="Residuals")
```
```{r linear model no outliers, Owners removed}
# Outliers removed
model2<- lm(log(ParameterValue)~ + LatitudeDD + LongitudeDD + WellUse + WellDepth
            + MeanWaterLvl, data = noOutliers)
plot(model2$fitted.values, model2$residuals, main = "Model2, Outliers & Owners Removed", xlab="Fitted Values", ylab="Residuals")
```
#### The residuals show evidence of non-constant variance. A closer investigation of the continuous variables is needed.
```{r searching for non-constant variance}
par(mfrow=c(1,2))
plot(log(ParameterValue) ~ LatitudeDD, data = noOutliers)
plot(log(ParameterValue) ~ LongitudeDD, data = noOutliers)
par(mfrow=c(1,2))
plot(log(ParameterValue) ~ SampleYear, data = noOutliers)
plot(log(ParameterValue) ~ MeanWaterLvl, data = noOutliers)
```
#### The scatterplots indicate 4 important relationships:
1. As latitude increases, TDS, decreases (the aforementioned north-south degredation in water quality exists on the county level)
2. As longitude increases, TDS decreases (an east-west degredation in water quality also exists.)
3. Serial corrleation is evident. Since 1940, TDS values trend upward. The water quality of these wells is decreasing.
4. As mean water levels decrease, so does water quality as measured by TDS.

Year and MeanWaterLvl are too highly correlated. Year will be removed, because water levels are more highly corrleated with TDS levels than Year.

```{r model1 summary, echo=F}
summary(model1)
```

#### The adjusted R-squared for model 1 is .72. Including well owners will overfit the model and are not great predictors of water quality. They will be taken out of the model.

```{r model 2 summary, echo=F}
summary(model2)
```
#### Model 2 has a much worse R squared value (.4273). 

```{r training and test set split}
set.seed(1234)
#creating an 80:20 train:test split
sample_size <- floor(0.80 * nrow(noOutliers))
index<- sample(seq_len(nrow(noOutliers)), size = sample_size)
outDF<- TDS_Waterlvl[outliers,]
outDF
train<- noOutliers[index,]
test<- noOutliers[-index,]
```
#### Before returning the outliers to the test set, an examination revealed that 9 out of 10 outliers were sampled in the year 1980. 8 samples were from well 2326306, belonging to a the Lubbock Children's Home. 2 samples were from the Benton Estate. All samples had a variant of the same note, "Sample collected from well...not filtered or preserved." These outliers appear to be caused by a malfunction of sorts and will not be reintroduced to the model.

For the automatic feature selection, we will put LandElevation back into the model to allow the algorithms more flexibility.
```{r creating predictor and response variables}

#Predictors saved as object
predictors<- model.matrix(~ + LatitudeDD + LongitudeDD + WellUse +WellDepth + LandSurfaceElevation 
                          + MeanWaterLvl + WellType, train) [,-1]

#had to remove Owners variable due to computer memory limits 
# the matrix created with the Owners variable took 65Gb ram, which is just beyond my computer's limit. 
response<- log(train$ParameterValue)
dim(predictors)
dim(response)
```
```{r ridge selection, eval=F}
library(glmnet)
cv.ridge <- cv.glmnet(predictors, response, alpha = 0)
cv.ridge$lambda.min
model.ridge <- glmnet(predictors, response, alpha = 0, lambda = cv.ridge$lambda.min)
ridge.indicators<- coef(model.ridge)
ridge.indicators
```

```{r ridge model test, eval=F}
library(tidyverse)
library(caret)
test.ridge <- model.matrix(~ + LatitudeDD + LongitudeDD + WellUse +WellDepth + LandSurfaceElevation 
                          + MeanWaterLvl + WellType, test) [,-1]
predictions.ridge <- model.ridge %>%
  predict(test.ridge) %>% 
  as.vector()
data.frame(
  RMSE.r = RMSE(predictions.ridge, log(test$ParameterValue)),
  Rsquare.r = R2(predictions.ridge, log(test$ParameterValue)))
```
```{r ridge plot}
```

```{r LASSO selection and testing, eval=F}
cv.l <- cv.glmnet(predictors, response, alpha = 1)
cv.l$lambda.min
model.lasso <- glmnet(predictors, response, alpha = 1, lambda = cv.l$lambda.min)
lasso.indicators<-coef(model.lasso)
lasso.indicators
test.lasso <- model.matrix(~ + LatitudeDD + LongitudeDD + WellUse +WellDepth + LandSurfaceElevation 
                          + MeanWaterLvl + WellType, test)[,-1]
predictions.lasso <- model.lasso %>%
  predict(test.lasso) %>% 
  as.vector()
data.frame(
  RMSE.l = RMSE(predictions.lasso, test$ParameterValue),
  Rsquare.l = R2(predictions.lasso, test$ParameterValue))
```
```{r Elastic Net selection and testing, eval=F}
#Caution, this sumbitch will tie up your computer 
model.net <- train(log(ParameterValue) ~ + LatitudeDD + LongitudeDD + WellUse +WellDepth 
                   + LandSurfaceElevation + MeanWaterLvl + WellType, 
                   data = train, 
                   method = "glmnet",
                   trControl = trainControl("cv", number = 10), 
                   tuneLength = 10)
model.net$bestTune
  
coef(model.net$finalModel, model.net$bestTune$lambda)
test.net <- model.matrix(log(ParameterValue) ~ + LatitudeDD + LongitudeDD + WellUse + WellDepth 
                         + LandSurfaceElevation + MeanWaterLvl + WellType, test)[,-1]
predictions.net <- model.net %>% 
  predict(test.net)
data.frame(
RMSE.net = RMSE(predictions.net, test$ParameterValue),
Rsquare.net = R2(predictions.net, test$ParameterValue))
```