---
title: "Water_Project"
author: "Justin Howard"
date: "June 6, 2019"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=F}
setwd('C:/Users/howar/Documents/r__working_directory/Water_Project')
```

```{r well descriptions, inlcude=F}
wellmain<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WellMain.txt", sep="|", header=T,
                      stringsAsFactors = T, strip.white = T, quote="", comment.char = "", fill = T)
```
```{r loading water quality data, include=F}
qualitymajor<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WaterQualityMajor.txt", sep="|",
                          header=T,stringsAsFactors = T, strip.white = T, quote="", comment.char = "", 
                          fill = T)
qualityminor<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WaterQualityMinor.txt", sep="|",
                          header=T, stringsAsFactors = T, strip.white = T, quote="", comment.char = "", 
                          fill = T)
qualitycombination<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WaterQualityCombination.txt",
                                sep="|", header=T, stringsAsFactors = T, strip.white = T, quote="",
                                comment.char = "", fill = T)
qualityotherunass<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WaterQualityOtherUnassigned.txt",
                               sep="|", header=T, stringsAsFactors = T, strip.white = T, quote="",
                               comment.char = "", fill = T)
```
```{r more well descriptions, include=F}
welllithology<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WellLithology.txt", sep="|", header=T,
                           stringsAsFactors = T, fill = T, quote= "")
welltest<- read.table("C:/Users/howar/Documents/Stats.2/Project 1/WellTest.txt", sep="|", header=T,
                      stringsAsFactors = T, fill = T)

```
```{r summary stats qualitymajor}
attach(qualitymajor)
filter=dplyr::filter
majorbrackish<-filter(qualitymajor, ParameterValue>1000)
summary(majorbrackish)
hist(majorbrackish$ParameterValue)
huge<- subset(qualitymajor, ParameterValue >300000)
huge
hist(huge$ParameterValue)
uptoquantile3<- subset(qualitymajor, ParameterValue < 30000)
```
```{r plots, eval=F, include=F}
plot(qualitymajor, x=SampleDate, y=ParameterValue)
ggplot(data = qualitymajor, aes(x=SampleDate, y = ParameterValue, group=SampledAquifer)) +
  geom_point() +
  geom_line()

ggplot(data = uptoquantile3, aes(x=SampleDate, y = ParameterValue, group=SampledAquifer)) +
  geom_point() +
  geom_line()
```
```{r pressure, echo=FALSE}
library(dplyr)
library(stringr)
```

#### We need to make a table of more useful data. We will ignore mostly empty columns: SampleBottomInterval, SampleTopInterval,  
```{r combining water quality tables}

QualityMerge<- function(a,b,c,d) {
  a1<- a %>%
    select(StateWellNumber, ParameterCode, County, Aquifer, SampleTime, SampledAquifer, ParameterDescription,
         ParameterValue,SampleDate, CollectionEntity) %>%
    filter(ParameterCode == 70301, ParameterValue > 1000)
  b1<- b %>% 
    select(StateWellNumber, ParameterCode, County, Aquifer, SampleTime, SampledAquifer, ParameterDescription,
         ParameterValue,SampleDate, CollectionEntity) %>%
    filter(ParameterCode == 70301, ParameterValue > 1000)
  c1<- c %>% 
    select(StateWellNumber, ParameterCode, County, Aquifer, SampleTime, SampledAquifer, ParameterDescription,
         ParameterValue,SampleDate, CollectionEntity) %>%
    filter(ParameterCode == 70301, ParameterValue > 1000)
  d1<- d %>% 
    select(StateWellNumber, ParameterCode, County, Aquifer, SampleTime, SampledAquifer, ParameterDescription,
         ParameterValue,SampleDate, CollectionEntity) %>%
    filter(ParameterCode == 70301, ParameterValue > 1000)
  all<- list(a1, b1, c1, d1)
  QualityAll<<- do.call("rbind", all)
  return(QualityAll)
}
QualityMerge(qualitycombination, qualitymajor, qualityminor, qualityotherunass)
library(tidyverse)
library(lubridate)
QualityAll$SampleDate<- ymd(QualityAll$SampleDate)
head(QualityAll)
```

```{r merging QualityAll and WellMain}
useful<- wellmain %>%
  select(StateWellNumber, AquiferCodeDescription, LatitudeDD, LongitudeDD, WellDepth, LandSurfaceElevation,
         DrillingStartDate, DrillingEndDate, WellType, WellUse, WaterLevelStatus, WaterQualityAvailable,
         CurrentWaterLevelWell, CurrentWaterQualityWell, RiverBasin, GMA, RWPA, Classification, Pump,
         PowerType)
Quality_plus <-merge(QualityAll, useful, by = "StateWellNumber", all.x = T) 
head(Quality_plus)
dim(Quality_plus)
dim(QualityAll)
```
```{r merging well lithology}
usefullithology<- welllithology %>%
  select(StateWellNumber, TopDepth, BottomDepth, LithologyDescription)
Quality_plus<- merge(Quality_plus, usefullithology, by = "StateWellNumber", all.x = T)
head(Quality_plus)
```
```{r cleaning}
Quality_plus$SampleDate<- ymd(Quality_plus$SampleDate)
Quality_plus$DrillingStartDate<- ymd(Quality_plus$DrillingStartDate)
Quality_plus$DrillingEndDate<- ymd(Quality_plus$DrillingEndDate)
Quality_plus$SampleTime<- as.numeric(Quality_plus$SampleTime)
Quality_plus$SampleTime<- sub("(\\d+)(\\d{2})", "\\1:\\2", Quality_plus$SampleTime) 

Quality_plus$SampleTime<- hm(Quality_plus$SampleTime, format= "%H:%M")
```
```{r summary of big dataset}
summary(Quality_plus)
```
#### To make a linear model based on the categoricals, we will identify the variables associated with individual wells and include them in a one-time TDS parametervalue to get an idea of the variables most associated with the presence of brackish water. Since the TDS parameter value is highly dependent on other variables, we will proceed with caution.
```{r finding categoricals unique to each well}
#filtering total data by individual wells
wellstats<- Quality_plus %>%
  group_by(StateWellNumber) %>%
  distinct(StateWellNumber, .keep_all = T)
summary(wellstats)
dim(wellstats)
length(wellstats$StateWellNumber)
```
#### We are left with 32 variables explaining 14,909 individual wells. We will proceed to plot diagnostics fo r the response, ParameterValue (TDS) and two other continuous variables: WellDepth and LandSurfaceElevation.
```{r finding percentage of NA in each column of wellstats}
colMeans(is.na(wellstats))
```
#### Columns with more than 80% NA values will not be considered in the model, but will be used for plotting to determine the strength of their relationship wih the response.
1. DrillingEndDate
2. WellDepth
3. TopDepth
4. BottomDepth
5. DrillingStartDate
6. LithologyDescription
There are still enough missing values to cause problems, so we will investigate them further.
```{r finding incomplete cases}
#creating dataframe from columns that will be used to create the linear model
# adding in StateWellNumber because it was used to group variables, but it won't be included in the model.
wellstatsmodel<- wellstats %>%
  dplyr::select(ParameterValue, LandSurfaceElevation, Aquifer, County, SampledAquifer, 
         RiverBasin, GMA, RWPA, Classification, CollectionEntity, WellType, 
         WellUse, Pump, PowerType, StateWellNumber)
#creating an index of complete cases
completeindex<- which(complete.cases(wellstatsmodel))
# the index contains the 14648 complete cases and 15 variables from the model table
# we will make a new table with only complete cases
wellstatsmodel<- wellstatsmodel[completeindex,]
dim(wellstatsmodel)
```
```{r plotting the response, include=F}
# BottomDepth would not plot, so it was removed.
pairs(~ParameterValue + WellDepth + LandSurfaceElevation + TopDepth, data = wellstats)

```
#### WellDepth and LandSurfaceElevation appear correlated. WellDepth and TopDepth also appear correlated. Points for all appear clustered, so constant standard deviation is problematic.
```{r scatterplots for location based categoricals}
# LithologyType could not be plotted, so it was removed.
pairs(~ParameterValue + Aquifer + County + SampledAquifer + RiverBasin + GMA + RWPA + 
         Classification,  data = wellstats)
```
#### Aquifer and Classification appear to be strongly correlated, as do SampledAquifer and Classification.

```{r scatterplots for non-locatoin based categoricals}
# CurrentWaterQualityWell would not plot, so it was removed
pairs(~ParameterValue + CollectionEntity + WellType + WellUse
      + Pump + PowerType,  data = wellstats)
```
#### Most categoricals do not appear to correlate with each other, except for WellType and CollectionEntity. There is evidence of a non-linear relationship between the repsonse and CollectionEntity, Pump and PowerType.
Before we proceed, we will look at scatterplots of a log transformed repsonse.
```{r plots of log transformed ParameterValue}
pairs(~log(ParameterValue) + WellDepth + LandSurfaceElevation + TopDepth, main = "Log Transformed Response v. Continuous Variables", data = wellstats)
pairs(~log(ParameterValue) + Aquifer + County + SampledAquifer + RiverBasin + GMA + RWPA + 
        Classification,  main = "Log Tranformed Response v. Location-Based Variables", data = wellstats)
pairs(~log(ParameterValue) + CollectionEntity + WellType + WellUse
      + Pump + PowerType,  main = "Log Transformed Response v. Other Variables", data = wellstats)
```
#### A quadratic relationiship appears evident between the logged ParameterValue and TopDepth and is somewhat reflected inthe WellDepth plot as well.
```{r linear model using table of complete cases}
model1<- lm(log(ParameterValue)~ LandSurfaceElevation + Aquifer + County + SampledAquifer 
            + RiverBasin + GMA + RWPA + Classification + CollectionEntity + WellType 
            + WellUse + Pump + PowerType, data = wellstatsmodel)
plot(model1$fitted.values, model1$residuals, xlab="Fitted Values", ylab="Residuals")
```
```{r model1 summary}
summary(model1)
```
#### The adjusted R-squared for this model is .2844. We will create a training and test set and use an automatic selection procedure to see if this can be improved.
```{r training and test set split}
set.seed(1234)
#creating an 80:20 train:test split
sample_size <- floor(0.80 * nrow(wellstatsmodel))
index<- sample(seq_len(nrow(wellstatsmodel)), size = sample_size)

train<- wellstatsmodel[index,]
test<- wellstatsmodel[-index,]
```

```{r creating predictor and response variables}

#Predictors saved as object
predictors<- model.matrix(~ LandSurfaceElevation + Aquifer + County + SampledAquifer + RiverBasin 
                          + GMA + RWPA + Classification + CollectionEntity + WellType + WellUse 
                          + Pump + PowerType, train) [,-1]
response<- train$ParameterValue
dim(predictors)
dim(response)
```
```{r ridge selection, eval=F}
cv.ridge <- cv.glmnet(predictors, response, alpha = 0)
cv.ridge$lambda.min
model.ridge <- glmnet(predictors, response, alpha = 0, lambda = cv.ridge$lambda.min)
coef(model.ridge)
```

```{r ridge model test, eval=F}
test.ridge <- model.matrix(~ LandSurfaceElevation + Aquifer + County + SampledAquifer + RiverBasin 
                          + GMA + RWPA + Classification + CollectionEntity + WellType + WellUse 
                          + Pump + PowerType, test) [,-1]
predictions.ridge <- model.ridge %>%
  predict(test.ridge) %>% 
  as.vector()
data.frame(
  RMSE.r = RMSE(predictions.ridge, test$ParameterValue),
  Rsquare.r = R2(predictions.ridge, test$ParameterValue))
```

```{r LASSO selection and testing, eval=F}
cv.l <- cv.glmnet(predictors, response, alpha = 1)
cv.l$lambda.min
model.lasso <- glmnet(predictors, response, alpha = 1, lambda = cv.l$lambda.min)

test.lasso <- model.matrix(~ LandSurfaceElevation + Aquifer + County + SampledAquifer + RiverBasin 
                          + GMA + RWPA + Classification + CollectionEntity + WellType + WellUse 
                          + Pump + PowerType, test)[,-1]
predictions.lasso <- model.lasso %>%
  predict(test.lasso) %>% 
  as.vector()
data.frame(
  RMSE.l = RMSE(predictions.lasso, test$ParameterValue),
  Rsquare.l = R2(predictions.lasso, test$ParameterValue))
```
```{r Elastic Net selection and testing, eval=F}
#Caution, this sumbitch will tie up your computer 
model.net <- train(ParameterValue ~ LandSurfaceElevation + Aquifer + County + SampledAquifer + RiverBasin 
                          + GMA + RWPA + Classification + CollectionEntity + WellType + WellUse 
                          + Pump + PowerType, data = train, method = "glmnet",
                   trControl = trainControl("cv", number = 10), tuneLength = 10)
model.net$bestTune
  
coef(model.net$finalModel, model.net$bestTune$lambda)
test.net <- model.matrix(ParameterValue ~LandSurfaceElevation + Aquifer + County + SampledAquifer 
                         + RiverBasin + GMA + RWPA + Classification + CollectionEntity + WellType 
                         + WellUse + Pump + PowerType, test)[,-1]
predictions.net <- model.net %>% predict(test.net)
data.frame(
RMSE.net = RMSE(predictions.net, test$ParameterValue),
Rsquare.net = R2(predictions.net, test$ParameterValue))
```